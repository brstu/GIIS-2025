# –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞ 4

## –¢–µ–º–∞: "–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞ ‚Ññ4-5. –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ –∏–≥—Ä"

## –¶–µ–ª—å —Ä–∞–±–æ—Ç—ã:
—Å–æ–∑–¥–∞—Ç—å –∏–≥—Ä–æ–≤—ã–µ –ø—Ä–æ–µ–∫—Ç—ã —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∫–∞–Ω–æ–Ω–∏—á–µ—Å–∫–æ–≥–æ
–≤–∏–∑—É–∞–ª–∞ –∏ –º–µ—Ö–∞–Ω–∏–∫, –¥–æ–ø–æ–ª–Ω–∏–≤ –∏—Ö —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—è–º–∏ –¥–ª—è
—Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ –æ–ø—ã—Ç–∞ –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–π –≥–ª—É–±–∏–Ω—ã. 

## –ó–∞–¥–∞—á–∞
–í–∞—Ä–∏–∞–Ω—Ç 8
 - –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –≥–µ–º—ã. –ú–∞—Å—Å–æ–≤–∞—è –æ—á–∏—Å—Ç–∫–∞ —Ä—è–¥–æ–≤ –∏–ª–∏ —Å—Ç–æ–ª–±—Ü–æ–≤.
 - –ö–æ–º–±–æ-–º–µ—Ö–∞–Ω–∏–∫–∞. –ú—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–æ—Ä –æ—á–∫–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ
—É–¥–∞—á–Ω—ã–µ —Ö–æ–¥—ã. 
8. –¢—Ä–∏ –≤ —Ä—è–¥


## –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è

–ü—Ä–∏–º–µ—Ä–Ω—ã–µ —à–∞–≥–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏:
1. –ê–Ω–∞–ª–∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π –∏–≥—Ä—ã:
 - –ò–∑—É—á–µ–Ω–∏–µ –º–µ—Ö–∞–Ω–∏–∫, –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∏–ª—è, —Å–ª–∞–±—ã—Ö –º–µ—Å—Ç.
2. –ü—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π:
 - –í—ã–±–æ—Ä 2 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –º–µ—Ö–∞–Ω–∏–∫, –¥–æ–ø–æ–ª–Ω—è—é—â–∏—Ö –≥–µ–π–º–ø–ª–µ–π.
3. –ü—Ä–æ—Ç–æ—Ç–∏–ø–∏—Ä–æ–≤–∞–Ω–∏–µ:
 - –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏ –∏–≥—Ä—ã —Å –∫–∞–Ω–æ–Ω–∏—á–µ—Å–∫–∏–º –≤–∏–∑—É–∞–ª–æ–º.
4. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π:
 - –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –Ω–æ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
5. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:
 - –°–±–æ—Ä –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏.
6. –§–∏–Ω–∞–ª—å–Ω–∞—è –¥–æ—Ä–∞–±–æ—Ç–∫–∞:
 - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∫–æ–¥–∞, —É–ª—É—á—à–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∏, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–π.
P.S. –∏–≥—Ä–æ–≤—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø—Ä–∏–º–µ—Ä–∞ —Å —Ü–µ–ª—å—é
–¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø—Ä–∏–º–µ—Ä–Ω—ã—Ö –æ–∂–∏–¥–∞–Ω–∏–π –æ—Ç –∏—Ç–æ–≥–æ–≤–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–Ω–µ—á–Ω–æ–π
—Ä–∞–±–æ—Ç—ã.

## –ö–æ–¥ –ø—Ä–æ–≥—Ä–∞–º–º—ã

```
import pygame
import random
import sys

pygame.init()
pygame.display.set_caption("–¢—Ä–∏ –≤ —Ä—è–¥!üôàü¶Ñüê®")

GRID_SIZE = 8
GEM_SIZE = 64
PADDING = 4

SCREEN_SIZE = GRID_SIZE * GEM_SIZE
screen = pygame.display.set_mode((SCREEN_SIZE, SCREEN_SIZE + 110))  # extra HUD space

FONT = pygame.font.SysFont("arial", 24)

GEM_SYMBOLS = ["üôà", "ü¶Ñ", "ü¶ñ", "üê±", "üê®"]


ROW_SPECIAL_COLOUR = (250, 250, 250)
COL_SPECIAL_COLOUR = (0, 255, 255)

FPS = 60
clock = pygame.time.Clock()


class Gem:
    def __init__(self, symbol, special=None):
        self.symbol = symbol
        self.special = special

    def draw(self, surf, x, y, selected=False):
        outer = pygame.Rect(x, y, GEM_SIZE, GEM_SIZE)
        pygame.draw.rect(surf, (40, 40, 40), outer)

        if selected:
            pygame.draw.rect(surf, (255, 215, 0), outer, 4)

        symbol_font = pygame.font.SysFont("segoeuiemoji", GEM_SIZE - 10)
        symbol_surface = symbol_font.render(self.symbol, True, (255, 255, 255))
        symbol_rect = symbol_surface.get_rect(center=outer.center)
        surf.blit(symbol_surface, symbol_rect)

        if self.special:
            if self.special == 'row':
                pygame.draw.line(surf, (255, 255, 0), (outer.left + 5, outer.centery), (outer.right - 5, outer.centery), 3)
            else:
                pygame.draw.line(surf, (255, 255, 0), (outer.centerx, outer.top + 5), (outer.centerx, outer.bottom - 5), 3)


class Board:
    def __init__(self):
        self.score = 0
        self.multiplier = 1
        self.grid = []
        self._shuffle_until_playable()

    def random_gem(self):
        return Gem(random.choice(GEM_SYMBOLS))

    def in_bounds(self, x, y):
        return 0 <= x < GRID_SIZE and 0 <= y < GRID_SIZE

    def _generate_random_grid(self):
        self.grid = [[self.random_gem() for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]

    def _shuffle_until_playable(self):
        for _ in range(1000):
            self._generate_random_grid()
            if not self.any_matches() and self.has_possible_move():
                return
        self._generate_random_grid()

    def swap(self, p1, p2):
        (x1, y1), (x2, y2) = p1, p2
        self.grid[y1][x1], self.grid[y2][x2] = self.grid[y2][x2], self.grid[y1][x1]

    def adjacent(self, p1, p2):
        (x1, y1), (x2, y2) = p1, p2
        return abs(x1 - x2) + abs(y1 - y2) == 1

    def find_matches(self):
        matches = []
        # horizontals
        for y in range(GRID_SIZE):
            run = [(0, y)]
            for x in range(1, GRID_SIZE):
                if self.grid[y][x].symbol == self.grid[y][x - 1].symbol:
                    run.append((x, y))
                else:
                    if len(run) >= 3:
                        matches.append(run)
                    run = [(x, y)]
            if len(run) >= 3:
                matches.append(run)

        for x in range(GRID_SIZE):
            run = [(x, 0)]
            for y in range(1, GRID_SIZE):
                if self.grid[y][x].symbol == self.grid[y - 1][x].symbol:
                    run.append((x, y))
                else:
                    if len(run) >= 3:
                        matches.append(run)
                    run = [(x, y)]
            if len(run) >= 3:
                matches.append(run)
        return matches

    def any_matches(self):
        return bool(self.find_matches())

    def has_possible_move(self):
        for y in range(GRID_SIZE):
            for x in range(GRID_SIZE):
                for dx, dy in ((1, 0), (0, 1)):
                    nx, ny = x + dx, y + dy
                    if not self.in_bounds(nx, ny):
                        continue
                    self.swap((x, y), (nx, ny))
                    found = self.find_matches()
                    self.swap((x, y), (nx, ny))
                    if found:
                        return True
        return False

    def apply_specials(self, matches):
        extra = set()
        for run in matches:
            for x, y in run:
                gem = self.grid[y][x]
                if gem.special == 'row':
                    for cx in range(GRID_SIZE):
                        extra.add((cx, y))
                elif gem.special == 'col':
                    for cy in range(GRID_SIZE):
                        extra.add((x, cy))
        for pos in extra:
            if pos not in [p for run in matches for p in run]:
                matches.append([pos])
        return matches

    def promote_specials(self, matches):
        for run in matches:
            if len(run) >= 4:
                x, y = random.choice(run)
                orientation = 'row' if all(y == yy for _, yy in run) else 'col'
                gem = self.grid[y][x]
                gem.special = orientation
                gem.colour = ROW_SPECIAL_COLOUR if orientation == 'row' else COL_SPECIAL_COLOUR

    def remove_matches(self, matches):
        removed = 0
        for run in matches:
            for x, y in run:
                self.grid[y][x] = None
                removed += 1
        return removed

    def drop_gems(self):
        for x in range(GRID_SIZE):
            empty = []
            for y in reversed(range(GRID_SIZE)):
                if self.grid[y][x] is None:
                    empty.append(y)
                elif empty:
                    dest = empty.pop(0)
                    self.grid[dest][x], self.grid[y][x] = self.grid[y][x], None
                    empty.append(y)
            for y in empty:
                self.grid[y][x] = self.random_gem()

    def resolve_board(self, startup=False):
        removed_any = False
        while True:
            matches = self.find_matches()
            if not matches:
                break
            removed_any = True
            matches = self.apply_specials(matches)
            self.promote_specials(matches)

            removed = self.remove_matches(matches)
            if not startup:
                self.score += removed * 10 * self.multiplier

            self.drop_gems()

        if not self.has_possible_move():
            self._shuffle_until_playable()
        return removed_any

    def positions_row(self, row):
        return [(x, row) for x in range(GRID_SIZE)]

    def positions_col(self, col):
        return [(col, y) for y in range(GRID_SIZE)]

    def remove_positions(self, positions):
        for x, y in positions:
            self.grid[y][x] = None


def main():
    board = Board()
    running = True

    selected = None
    combo_streak = 0

    bomb_active = False
    bomb_timer = 0
    bomb_positions = []

    restart_rect = pygame.Rect(SCREEN_SIZE - 160, SCREEN_SIZE + 30, 140, 40)

    while running:
        clock.tick(FPS)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                mx, my = event.pos

                # –ö–Ω–æ–ø–∫–∞ "Restart"
                if restart_rect.collidepoint(event.pos):
                    board = Board()
                    selected = None
                    combo_streak = 0
                    bomb_active = False
                    bomb_timer = 0
                    bomb_positions = []
                    continue

                if bomb_active or my > SCREEN_SIZE:
                    continue

                x, y = mx // GEM_SIZE, my // GEM_SIZE

                if selected is None:
                    selected = (x, y)
                    continue

                if board.adjacent(selected, (x, y)):
                    board.swap(selected, (x, y))
                    initial_matches = board.find_matches()
                    success = bool(initial_matches)

                    if success:
                        board.resolve_board()
                        board.multiplier += 1
                        combo_streak += 1

                        if combo_streak % 10 == 0:
                            sx, sy = selected
                            tx, ty = x, y
                            target_run = next((run for run in initial_matches
                                               if (sx, sy) in run or (tx, ty) in run),
                                              initial_matches[0])
                            if all(yy == target_run[0][1] for _, yy in target_run):
                                index = target_run[0][1]
                                bomb_positions = board.positions_row(index)
                            else:
                                index = target_run[0][0]
                                bomb_positions = board.positions_col(index)

                            bomb_active = True
                            bomb_timer = 20
                    else:
                        board.swap(selected, (x, y))
                        board.multiplier = 1
                        combo_streak = 0

                    selected = None

        if bomb_active:
            bomb_timer -= 1
            if bomb_timer <= 0:
                board.remove_positions(bomb_positions)
                board.drop_gems()
                board.resolve_board()
                bomb_active = False
                bomb_positions.clear()

   
        screen.fill((255, 182, 193))  # —Ä–æ–∑–æ–≤—ã–π —Ñ–æ–Ω

        for y in range(GRID_SIZE):
            for x in range(GRID_SIZE):
                gem = board.grid[y][x]
                if gem:
                    gem.draw(screen, x * GEM_SIZE, y * GEM_SIZE, selected == (x, y))

        if bomb_active and (bomb_timer // 3) % 2 == 0:
            overlay = pygame.Surface((GEM_SIZE, GEM_SIZE), pygame.SRCALPHA)
            overlay.fill((255, 255, 255, 140))
            for x, y in bomb_positions:
                screen.blit(overlay, (x * GEM_SIZE, y * GEM_SIZE))

      
        hud_score = FONT.render(f"Score: {board.score}", True, (255, 255, 255))
        hud_mult = FONT.render(f"Multiplier: x{board.multiplier}", True, (255, 255, 255))
        hud_combo = FONT.render(f"Streak: {combo_streak}", True, (255, 255, 255))

        screen.blit(hud_score, (10, SCREEN_SIZE + 10))
        screen.blit(hud_mult, (10, SCREEN_SIZE + 40))
        screen.blit(hud_combo, (10, SCREEN_SIZE + 70))


        pygame.draw.rect(screen, (255, 255, 255), restart_rect, border_radius=10)
        label = FONT.render("Restart", True, (255, 105, 180))
        label_rect = label.get_rect(center=restart_rect.center)
        screen.blit(label, label_rect)

        pygame.display.flip()

    pygame.quit()
    sys.exit()



if __name__ == "__main__":
    main()

```
 
## –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞–±–æ—Ç—ã
1. –ù–∞—á–∞–ª—å–Ω—ã–π —ç–∫—Ä–∞–Ω –∏–≥—Ä—ã
![](images/1.png)
–ü–æ–º–∏–º–æ —Å–∞–º–æ–≥–æ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç —Å–ª–µ–¥—É—é—â–∏–µ –ø–æ–ª—è:
   1. Score - —Ç–µ–∫—É—â–∏–π —Å—á—ë—Ç –∏–≥—Ä–æ–∫–∞.
   2. Multituple - –º–Ω–æ–∂–∏—Ç–µ–ª—å –æ—á–∫–æ–≤ (x1, x2, –∏ —Ç. –¥.), –∫–æ—Ç–æ—Ä—ã–π —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —É—Å–ø–µ—à–Ω—ã—Ö –ø–æ–¥—Ä—è–¥ –∏–¥—É—â–∏—Ö —Ö–æ–¥–∞—Ö.
   3. Streak - —Å–µ—Ä–∏—è —É–¥–∞—á–Ω—ã—Ö —Ö–æ–¥–æ–≤ –ø–æ–¥—Ä—è–¥ (–∫–æ–º–±–æ).
   4. Restart - –∫–Ω–æ–ø–∫–∞, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏–≥—Ä—É –∑–∞–Ω–æ–≤–æ.


2. üéØ –¶–µ–ª—å –∏–≥—Ä—ã

–ò–≥—Ä–æ–∫ –¥–æ–ª–∂–µ–Ω –º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏ —Å–æ—Å–µ–¥–Ω–∏–µ —ç–º–æ–¥–∑–∏, —á—Ç–æ–±—ã –æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –∏–ª–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ —Ä—è–¥—ã –∏–∑ —Ç—Ä—ë—Ö –∏ –±–æ–ª–µ–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö —Ñ–∏—à–µ–∫. –ö–æ–≥–¥–∞ —Ç–∞–∫–∏–µ —Ä—è–¥—ã –æ–±—Ä–∞–∑—É—é—Ç—Å—è, —Ñ–∏—à–∫–∏ –∏—Å—á–µ–∑–∞—é—Ç, –∏ –∑–∞ —ç—Ç–æ –Ω–∞—á–∏—Å–ª—è—é—Ç—Å—è –æ—á–∫–∏.

–ü—Ä–∞–≤–∏–ª–∞ –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –±–∞–ª–ª–æ–≤:

1. –ë–∞–∑–æ–≤–æ–µ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–µ
–ö–∞–∂–¥–∞—è —É–¥–∞–ª—ë–Ω–Ω–∞—è —Ñ–∏—à–∫–∞ –ø—Ä–∏–Ω–æ—Å–∏—Ç 10 –æ—á–∫–æ–≤, —É–º–Ω–æ–∂–µ–Ω–Ω—ã—Ö –Ω–∞ —Ç–µ–∫—É—â–∏–π –º–Ω–æ–∂–∏—Ç–µ–ª—å (multiplier).

score += –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_—É–¥–∞–ª—ë–Ω–Ω—ã—Ö_—Ñ–∏—à–µ–∫ √ó 10 √ó multiplier
–ü—Ä–∏–º–µ—Ä:
–ï—Å–ª–∏ –∏—Å—á–µ–∑–ª–æ 5 —Ñ–∏—à–µ–∫ –∏ —Ç–µ–∫—É—â–∏–π –º–Ω–æ–∂–∏—Ç–µ–ª—å —Ä–∞–≤–µ–Ω 2, —Ç–æ:

–û—á–∫–∏ = 5 √ó 10 √ó 2 = 100

![](images/2.png)


2. Multiplier (–º–Ω–æ–∂–∏—Ç–µ–ª—å)
–ú–Ω–æ–∂–∏—Ç–µ–ª—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—á–∫–æ–≤ –∑–∞ —É—Å–ø–µ—à–Ω—ã–µ —Ö–æ–¥—ã.

–ù–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: x1

–ö–∞–∂–¥—ã–π —É—Å–ø–µ—à–Ω—ã–π —Ö–æ–¥ –ø–æ–¥—Ä—è–¥ (—Ç.–µ. —Ç–∞–∫–æ–π, –ø–æ—Å–ª–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—Ä–æ–∏–∑–æ—à—ë–ª –≤–∑—Ä—ã–≤ —Ñ–∏—à–µ–∫) —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –º–Ω–æ–∂–∏—Ç–µ–ª—å –Ω–∞ 1:

x1 ‚Üí x2 ‚Üí x3 ‚Üí ‚Ä¶ (–±–µ–∑ –≤–µ—Ä—Ö–Ω–µ–≥–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è)
–ï—Å–ª–∏ –∏–≥—Ä–æ–∫ —Å–¥–µ–ª–∞–ª –Ω–µ—É—Å–ø–µ—à–Ω—ã–π —Ö–æ–¥ (–ø–æ–º–µ–Ω—è–ª —Ñ–∏—à–∫–∏, –Ω–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ –ø—Ä–æ–∏–∑–æ—à–ª–æ):

multiplier —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ x1.
![](images/3.png)
3. Streak (—Å–µ—Ä–∏—è —É–¥–∞—á–Ω—ã—Ö —Ö–æ–¥–æ–≤)
–°—á—ë—Ç—á–∏–∫ –ø–æ–¥—Ä—è–¥ –∏–¥—É—â–∏—Ö —É—Å–ø–µ—à–Ω—ã—Ö —Ö–æ–¥–æ–≤ (–±–µ–∑ –æ—à–∏–±–æ–∫).

–ö–∞–∂–¥—ã–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –¥–µ–ª–∞–µ—Ç —É–¥–∞—á–Ω—ã–π —Ö–æ–¥ ‚Äî streak += 1.

–ü—Ä–∏ –Ω–µ—É–¥–∞—á–Ω–æ–º —Ö–æ–¥–µ ‚Äî streak = 0.
![](images/4.png)
4. –ë–æ–Ω—É—Å-–±–æ–º–±–∞
–ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –¥–µ–ª–∞–µ—Ç 10 —É—Å–ø–µ—à–Ω—ã—Ö —Ö–æ–¥–æ–≤ –ø–æ–¥—Ä—è–¥ (—Ç.–µ. streak % 10 == 0), –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –±–æ–º–±–∞:

–í–∑—Ä—ã–≤–∞–µ—Ç—Å—è –≤—Å—è —Å—Ç—Ä–æ–∫–∞ –∏–ª–∏ –≤–µ—Å—å —Å—Ç–æ–ª–±–µ—Ü, –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, –≥–¥–µ –±—ã–ª–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ.

–í—Å–µ —Ñ–∏—à–∫–∏ –≤ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ –∏–ª–∏ —Å—Ç–æ–ª–±—Ü–µ –∏—Å—á–µ–∑–∞—é—Ç ‚Äî –∑–∞ –∫–∞–∂–¥—É—é –∏–∑ –Ω–∏—Ö –Ω–∞—á–∏—Å–ª—è—é—Ç—Å—è –æ—á–∫–∏ –ø–æ —Ç–æ–π –∂–µ —Ñ–æ—Ä–º—É–ª–µ:

–æ—á–∫–∏ = —á–∏—Å–ª–æ —Ñ–∏—à–µ–∫ √ó 10 √ó multiplier
–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ streak –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è, –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.

–î–æ –±–æ–º–±—ã:
![](images/5.png)

–ê–Ω–∏–º–∞—Ü–∏—è –±–æ–º–±—ã:
![](images/6.png)
–ü–æ—Å–ª–µ –±–æ–º–±—ã:
![](images/7.png)


üîÅ –°—Ü–µ–Ω–∞—Ä–∏–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –±–∞–ª–ª–æ–≤:
–ò–≥—Ä–æ–∫ –¥–µ–ª–∞–µ—Ç —Ö–æ–¥.

–ï—Å–ª–∏ –æ–±—Ä–∞–∑–æ–≤–∞–ª–∞—Å—å –∫–æ–º–±–∏–Ω–∞—Ü–∏—è:

–ö–æ–º–±–∏–Ω–∞—Ü–∏—è —É–¥–∞–ª—è–µ—Ç—Å—è.

–í—ã–ø–∞–¥–∞—é—Ç –Ω–æ–≤—ã–µ —Ñ–∏—à–∫–∏.

–ù–∞—á–∏—Å–ª—è—é—Ç—Å—è –æ—á–∫–∏:

+10 –∑–∞ –∫–∞–∂–¥—É—é —É–¥–∞–ª—ë–Ω–Ω—É—é —Ñ–∏—à–∫—É √ó multiplier.

multiplier += 1

streak += 1

–ï—Å–ª–∏ streak % 10 == 0 ‚Üí –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è ‚Äú–±–æ–º–±–∞‚Äù.

–ï—Å–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –Ω–µ –æ–±—Ä–∞–∑–æ–≤–∞–ª–∏—Å—å:

multiplier = 1

streak = 0

–•–æ–¥ –æ—Ç–º–µ–Ω—è–µ—Ç—Å—è (—Ñ–∏—à–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–∞).

